{"ast":null,"code":"import { D2R, R2D, PJD_3PARAM, PJD_7PARAM } from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\n\nfunction checkNotWGS(source, dest) {\n  return (source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84' || (dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84';\n}\n\nexport default function transform(source, dest, point) {\n  var wgs84;\n\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n\n  checkSanity(point); // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  } // DGR, 2010/11/12\n\n\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  } // Transform source points to long/lat, if they aren't already.\n\n\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n\n    point = source.inverse(point); // Convert Cartesian to longlat\n\n    if (!point) {\n      return;\n    }\n  } // Adjust for the prime meridian if necessary\n\n\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  } // Convert datums if needed, and if possible.\n\n\n  point = datum_transform(source.datum, dest.datum, point);\n\n  if (!point) {\n    return;\n  } // Adjust for the prime meridian if necessary\n\n\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else {\n    // else project\n    point = dest.forward(point);\n\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  } // DGR, 2010/11/12\n\n\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}","map":{"version":3,"sources":["/home/enrique/projects/TFG/node_modules/proj4/lib/transform.js"],"names":["D2R","R2D","PJD_3PARAM","PJD_7PARAM","datum_transform","adjust_axis","proj","toPoint","checkSanity","checkNotWGS","source","dest","datum","datum_type","datumCode","transform","point","wgs84","Array","isArray","axis","projName","x","y","z","to_meter","inverse","from_greenwich","forward"],"mappings":"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","sourcesContent":["import {D2R, R2D, PJD_3PARAM, PJD_7PARAM} from './constants/values';\nimport datum_transform from './datum_transform';\nimport adjust_axis from './adjust_axis';\nimport proj from './Proj';\nimport toPoint from './common/toPoint';\nimport checkSanity from './checkSanity';\n\nfunction checkNotWGS(source, dest) {\n  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');\n}\n\nexport default function transform(source, dest, point) {\n  var wgs84;\n  if (Array.isArray(point)) {\n    point = toPoint(point);\n  }\n  checkSanity(point);\n  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84\n  if (source.datum && dest.datum && checkNotWGS(source, dest)) {\n    wgs84 = new proj('WGS84');\n    point = transform(source, wgs84, point);\n    source = wgs84;\n  }\n  // DGR, 2010/11/12\n  if (source.axis !== 'enu') {\n    point = adjust_axis(source, false, point);\n  }\n  // Transform source points to long/lat, if they aren't already.\n  if (source.projName === 'longlat') {\n    point = {\n      x: point.x * D2R,\n      y: point.y * D2R,\n      z: point.z || 0\n    };\n  } else {\n    if (source.to_meter) {\n      point = {\n        x: point.x * source.to_meter,\n        y: point.y * source.to_meter,\n        z: point.z || 0\n      };\n    }\n    point = source.inverse(point); // Convert Cartesian to longlat\n    if (!point) {\n      return;\n    }\n  }\n  // Adjust for the prime meridian if necessary\n  if (source.from_greenwich) {\n    point.x += source.from_greenwich;\n  }\n\n  // Convert datums if needed, and if possible.\n  point = datum_transform(source.datum, dest.datum, point);\n  if (!point) {\n    return;\n  }\n\n  // Adjust for the prime meridian if necessary\n  if (dest.from_greenwich) {\n    point = {\n      x: point.x - dest.from_greenwich,\n      y: point.y,\n      z: point.z || 0\n    };\n  }\n\n  if (dest.projName === 'longlat') {\n    // convert radians to decimal degrees\n    point = {\n      x: point.x * R2D,\n      y: point.y * R2D,\n      z: point.z || 0\n    };\n  } else { // else project\n    point = dest.forward(point);\n    if (dest.to_meter) {\n      point = {\n        x: point.x / dest.to_meter,\n        y: point.y / dest.to_meter,\n        z: point.z || 0\n      };\n    }\n  }\n\n  // DGR, 2010/11/12\n  if (dest.axis !== 'enu') {\n    return adjust_axis(dest, true, point);\n  }\n\n  return point;\n}\n"]},"metadata":{},"sourceType":"module"}